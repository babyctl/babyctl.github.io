{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"babyctl","text":"<p>If Terraform and kubectl had a baby, it would feel a lot like babyctl.</p> <p>Active development</p> <p>babyctl is rapidly evolving. Expect dragons, gremlins, and fast-moving feature work while the core experience stabilises.</p> <p>babyctl lets you interact with any infrastructure that Terraform can describe while keeping the ergonomics of kubectl. The goal is to provide <code>kubectl</code>-style workflows\u2014<code>get</code>, <code>apply</code>, <code>edit</code>, <code>diff</code>, and more\u2014without depending on a running Kubernetes cluster.</p>"},{"location":"#why-babyctl","title":"Why babyctl?","text":"<ul> <li>Zero-import applies \u2013 point <code>babyctl apply</code> at pre-existing infrastructure to bring it under control without painful Terraform imports.</li> <li>Unified discovery \u2013 <code>babyctl api-resources</code> merges Kubernetes and Terraformer API discovery into one familiar list.</li> <li>Multi-format fluency \u2013 switch between YAML, HCL, and JSON with a single flag when you need the view that makes sense.</li> <li>Crisis-friendly editing \u2013 <code>babyctl edit</code> opens live infrastructure in your editor so you can perform surgical changes just like you would with kubectl.</li> <li>Kubernetes ecosystem compatible \u2013 pipe the output of tools such as Kustomize straight into <code>babyctl</code> to reuse all of your favourite config machinery.</li> </ul>"},{"location":"#key-use-cases","title":"Key use cases","text":"<ol> <li>Bring click-ops infrastructure under control</li> <li>Inspect resources with <code>babyctl get</code>.</li> <li>Run <code>babyctl apply -f existing.yaml</code> to adopt them without juggling Terraform state imports.</li> <li>Leverage Kubernetes tooling for Terraform resources</li> <li><code>kustomize build overlays/prod | babyctl apply -f -</code> works against anything Terraformer can reach.</li> <li>Emergency edits</li> <li>When production is on fire, open the resource directly via <code>babyctl edit</code> and keep the lights on.</li> <li>Format conversion</li> <li>Convert back and forth with <code>babyctl convert -f terraform.tf -oyaml</code> or <code>-ohcl</code>.</li> </ol>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code># Install babyctl\nmake install\n\n# Discover available resources from kubectl and Terraformer\nbabyctl api-resources\n\n# Apply configuration from stdin\nkustomize build overlays/dev | babyctl apply -f-\n\n# Convert Terraform to YAML\nbabyctl convert -f terraform.tf -oyaml\n</code></pre> <p>See the Getting Started guide for detailed setup steps.</p>"},{"location":"#supported-commands","title":"Supported commands","text":"Command Description <code>api-resources</code> List API resources available via kubectl and Terraformer <code>api-server</code> Run a Kubernetes-compatible discovery server backed by babyctl definitions <code>api-versions</code> Show supported API versions <code>apply</code> Apply a declarative configuration to a live resource <code>convert</code> Translate files between HCL, YAML, and JSON <code>delete</code> Delete live resources <code>diff</code> Compare live resources against would-be applies <code>edit</code> Open a resource in <code>$EDITOR</code> and persist edits live <code>explain</code> Display documentation about a resource <code>get</code> Retrieve one or many resources <code>version</code> Print client and server versions <p>For full flag details see the CLI reference.</p>"},{"location":"#release-automation","title":"Release automation","text":"<p>babyctl uses GitHub Actions and release-please to cut releases automatically. Follow Conventional Commits so release-please can determine semantic versions and changelog entries. See the contributing guide for details.</p>"},{"location":"#learn-more","title":"Learn more","text":"<ul> <li>Getting started</li> <li>Common workflows</li> <li>Kubectl integration</li> <li>Architecture deep dive</li> <li>Development workflow</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>babyctl mirrors the architectural approach used by kubectl so that contributors can reuse familiar patterns while extending the CLI to Terraform-managed infrastructure.</p>"},{"location":"architecture/#high-level-design","title":"High-level design","text":"<ul> <li>Cobra everywhere \u2013 each command is a <code>cobra.Command</code> registered from <code>pkg/cmd</code>. Commands own their flags, examples, and   validation logic.</li> <li>Passthrough-first implementation \u2013 most commands currently delegate to kubectl or Terraformer binaries. This keeps the UX   compatible while leaving room for native implementations later.</li> <li>Composable packages \u2013 helper libraries (printers, Terraformer helpers, API discovery) live under <code>pkg/</code> so they can be   reused by new commands or external tooling.</li> </ul>"},{"location":"architecture/#project-structure","title":"Project structure","text":"<pre><code>cmd/\n  babyctl/        # main.go creates the root command\npkg/\n  cmd/            # CLI command implementations\n  apiresources/   # Aggregates discovery information from kubectl + Terraformer\n  terraformer/    # Wrappers around the terraformer CLI\n  printers/       # Output helpers (tables, YAML/HCL conversion)\nexamples/\n  api-definitions # Sample discovery data served by the API server\n</code></pre> <p>Keep <code>main.go</code> minimal\u2014bootstrap logging, create the root command, and hand off to Cobra.</p>"},{"location":"architecture/#resource-discovery-pipeline","title":"Resource discovery pipeline","text":"<ol> <li><code>pkg/apiresources</code> shells out to <code>kubectl api-resources</code>.</li> <li><code>pkg/terraformer</code> introspects Terraformer providers and resources.</li> <li>Results are normalised into Kubernetes-style <code>APIResource</code> structs and merged.</li> <li>Commands such as <code>babyctl api-resources</code>, <code>babyctl api-versions</code>, and the discovery API server use this merged list.</li> </ol> <p>This pipeline enables familiar commands such as <code>kubectl api-resources</code> to show Terraform resources when pointed at the babyctl API server.</p>"},{"location":"architecture/#adding-a-command","title":"Adding a command","text":"<ol> <li>Create <code>pkg/cmd/&lt;name&gt;.go</code> returning a configured <code>*cobra.Command</code>.</li> <li>Wire the command up in <code>pkg/cmd/cmd.go</code> (or the relevant parent command) by calling the constructor.</li> <li>Keep business logic in helper packages so the command stays thin and testable.</li> <li>Add tests under <code>pkg/&lt;area&gt;</code> or integration tests under <code>test/</code> once they exist.</li> </ol> <p>Follow the same conventions as kubectl: short/long descriptions, <code>Examples</code> blocks, and logical flag groups.</p>"},{"location":"architecture/#api-server","title":"API server","text":"<p><code>babyctl api-server</code> exposes Kubernetes discovery endpoints only\u2014it does not implement CRUD. The server:</p> <ul> <li>Serves <code>/api</code> and <code>/apis</code> based on the merged discovery cache.</li> <li>Reads static definitions from <code>~/.babyctl/apis</code> so you can layer in your own groups/versions.</li> <li>Enables kubectl to target Terraform resources via <code>kubectl --server=http://localhost:8080 api-resources</code>.</li> </ul> <p>See kubectl integration for hands-on steps.</p>"},{"location":"architecture/#formatting-and-output","title":"Formatting and output","text":"<p>Printers under <code>pkg/printers</code> take care of rendering tables, YAML, JSON, or HCL. The <code>convert</code> command leans on these utilities to round-trip between formats so teams can choose the representation that fits their workflow.</p>"},{"location":"architecture/#testing-strategy","title":"Testing strategy","text":"<ul> <li>Unit tests live alongside packages (e.g. <code>pkg/apiresources/apiresources_test.go</code>).</li> <li>Integration tests use the <code>test-api-server.sh</code> helper or future suites under <code>test/</code> to validate CLI interactions.</li> <li>Run <code>make test</code> locally and rely on GitHub Actions for CI coverage.</li> </ul>"},{"location":"architecture/#key-dependencies","title":"Key dependencies","text":"<ul> <li>Cobra for command parsing.</li> <li>Terraformer for discovering Terraform resources.</li> <li>Standard Go libraries for HTTP, JSON, and file IO.</li> </ul> <p>Consult <code>ARCHITECTURE.md</code> for a more exhaustive blueprint when contributing major features.</p>"},{"location":"cli-reference/","title":"CLI reference","text":"<p>Every command is implemented with Cobra and mirrors the kubectl UX wherever possible. Use <code>babyctl &lt;command&gt; --help</code> for the authoritative flag list. This page summarises the intent and primary flags for each command.</p>"},{"location":"cli-reference/#global-flags","title":"Global flags","text":"<ul> <li><code>--server</code> \u2013 Override the API server to talk to (useful with <code>babyctl api-server</code>).</li> <li><code>--kubeconfig</code> \u2013 Provide a kubeconfig file when leveraging kubectl discovery.</li> <li><code>-o</code>, <code>--output</code> \u2013 Select table, yaml, json, or hcl output where supported.</li> <li><code>--source</code> \u2013 Limit discovery to <code>kubectl</code> or <code>terraformer</code> when running <code>api-resources</code>.</li> </ul>"},{"location":"cli-reference/#command-catalog","title":"Command catalog","text":""},{"location":"cli-reference/#api-resources","title":"api-resources","text":"<p>Lists all resources that babyctl can discover from kubectl and Terraformer.</p> <pre><code>babyctl api-resources [--source kubectl|terraformer]\n</code></pre>"},{"location":"cli-reference/#api-server","title":"api-server","text":"<p>Starts a lightweight discovery server that exposes <code>/api</code>, <code>/apis</code>, and <code>/apis/&lt;group&gt;/&lt;version&gt;</code> so that kubectl (or other clients) can discover the combined API surface. Pair with the kubectl integration guide.</p> <pre><code>babyctl api-server --port 8080\n</code></pre>"},{"location":"cli-reference/#api-versions","title":"api-versions","text":"<p>Displays the API versions served by the local discovery cache.</p> <pre><code>babyctl api-versions\n</code></pre>"},{"location":"cli-reference/#apply","title":"apply","text":"<p>Applies a manifest to the target infrastructure, mirroring <code>kubectl apply</code> semantics.</p> <pre><code>babyctl apply -f infra.yaml\nbabyctl apply -f- &lt; manifest.yaml\n</code></pre> <p>Important flags:</p> <ul> <li><code>-f, --filename</code> \u2013 File, directory, or <code>-</code> for stdin.</li> <li><code>--dry-run</code> \u2013 Validate manifests without persisting changes.</li> <li><code>--force-conflicts</code> \u2013 Adopt resources even when the live state differs.</li> </ul>"},{"location":"cli-reference/#convert","title":"convert","text":"<p>Translates between file formats to enable round-trips with Terraform.</p> <pre><code>babyctl convert -f terraform.tf -oyaml\n</code></pre> <p>Use <code>-oyaml</code>, <code>-ojson</code>, or <code>-ohcl</code> to choose the destination format.</p>"},{"location":"cli-reference/#delete","title":"delete","text":"<p>Deletes the specified resources.</p> <pre><code>babyctl delete -f infra.yaml\nbabyctl delete deployment/my-app\n</code></pre>"},{"location":"cli-reference/#diff","title":"diff","text":"<p>Shows the delta between live resources and the manifests that would be applied.</p> <pre><code>babyctl diff -f infra.yaml\n</code></pre>"},{"location":"cli-reference/#edit","title":"edit","text":"<p>Fetches a live resource, opens it in <code>$EDITOR</code>, and applies the diff when you save and exit\u2014just like <code>kubectl edit</code>.</p> <pre><code>babyctl edit deployment/my-app\n</code></pre>"},{"location":"cli-reference/#explain","title":"explain","text":"<p>Prints schema information for a resource type.</p> <pre><code>babyctl explain terraformer.aws.vpc\n</code></pre>"},{"location":"cli-reference/#get","title":"get","text":"<p>Retrieves resources in table or structured formats.</p> <pre><code>babyctl get deployments\nbabyctl get deployment/my-app -oyaml\n</code></pre>"},{"location":"cli-reference/#version","title":"version","text":"<p>Displays the client version and, when applicable, the API server version.</p> <pre><code>babyctl version\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for helping improve babyctl! This guide explains expectations for contributors and maintainers.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of conduct","text":"<p>Be excellent to each other. Treat all community members with respect and empathy.</p>"},{"location":"contributing/#workflow","title":"Workflow","text":"<ol> <li>Fork the repository or create a feature branch.</li> <li>Make your changes with clear, focused commits.</li> <li>Add or update tests when behaviour changes.</li> <li>Run <code>make check</code> locally to ensure formatting, linting, and tests all pass.</li> <li>Open a pull request describing the change and referencing any related issues.</li> </ol>"},{"location":"contributing/#commit-messages","title":"Commit messages","text":"<p>babyctl uses Conventional Commits. Examples:</p> <pre><code>git commit -m \"fix: patch panic when provider list is empty\"\ngit commit -m \"feat: add diff command\"\ngit commit -m \"feat!: redesign apply flow\\n\\nBREAKING CHANGE: requires explicit provider\"\n</code></pre> <p>Following this format allows release-please to determine semantic version bumps automatically.</p>"},{"location":"contributing/#review-checklist","title":"Review checklist","text":"<ul> <li>[ ] Code is formatted with <code>go fmt</code>.</li> <li>[ ] Tests pass locally (<code>make test</code>).</li> <li>[ ] User-facing changes are documented under <code>docs/</code>.</li> <li>[ ] New commands include helpful examples in <code>Examples</code> blocks.</li> <li>[ ] CLI output changes are covered by tests or manually verified screenshots/logs.</li> </ul>"},{"location":"contributing/#release-workflow","title":"Release workflow","text":"<p>Releases are driven by release-please:</p> <ol> <li>Merge changes into <code>main</code> using Conventional Commits.</li> <li>release-please opens or updates a release PR when it detects new commits.</li> <li>Once the release PR is merged, GitHub Actions publishes binaries (linux/darwin/windows for amd64+arm64), SHA256 checksums, and auto-generated changelog entries.</li> </ol>"},{"location":"contributing/#documentation-site","title":"Documentation site","text":"<p>Docs live under <code>docs/</code> and are rendered with MkDocs Material.</p> <pre><code>pip install mkdocs-material\nmkdocs serve\n</code></pre> <p>This spins up a live-reloading dev server at <code>http://127.0.0.1:8000</code>. Submit doc updates alongside code changes whenever possible.</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Open an issue or start a discussion on GitHub. We're excited to see what you build!</p>"},{"location":"development/","title":"Development workflow","text":""},{"location":"development/#toolchain","title":"Toolchain","text":"<ul> <li>Go 1.20+</li> <li>make</li> <li>golangci-lint (optional but recommended)</li> <li>Terraformer + kubectl for manual testing</li> </ul>"},{"location":"development/#common-tasks","title":"Common tasks","text":"<pre><code># Format code\ngo fmt ./...\n\n# Lint\ngo vet ./...\n\n# Run unit tests\nmake test\n\n# Run the whole suite (fmt + lint + test)\nmake check\n\n# Build the CLI\nmake build\n\n# Clean build artifacts\nmake clean\n</code></pre>"},{"location":"development/#running-the-api-server-locally","title":"Running the API server locally","text":"<pre><code>mkdir -p ~/.babyctl\ncp -r examples/api-definitions/apis ~/.babyctl/\n\nbabyctl api-server --port 8080\n</code></pre> <p>You can now point kubectl at <code>http://localhost:8080</code> as described in the kubectl integration guide.</p>"},{"location":"development/#repository-layout","title":"Repository layout","text":"<ul> <li><code>cmd/babyctl</code> \u2013 main entry point. Keep it thin.</li> <li><code>pkg/cmd</code> \u2013 home of all Cobra commands. Add a new file per command and register it with the root command.</li> <li><code>pkg/apiresources</code> \u2013 collects resource info from kubectl + Terraformer.</li> <li><code>pkg/terraformer</code> \u2013 helper functions for shelling out to Terraformer.</li> <li><code>pkg/printers</code> \u2013 output helpers shared by <code>get</code>, <code>apply</code>, and <code>convert</code>.</li> <li><code>examples/</code> \u2013 sample API definitions for demos and integration tests.</li> </ul>"},{"location":"development/#testing-tips","title":"Testing tips","text":"<ul> <li>Unit test packages in isolation where possible. For CLI behaviour, test the helper functions that power commands instead of the   Cobra plumbing.</li> <li>Use the provided <code>test-api-server.sh</code> script to exercise discovery endpoints end-to-end.</li> <li>Validate HCL/YAML conversions with golden files to catch formatting regressions.</li> </ul>"},{"location":"development/#releasing","title":"Releasing","text":"<p>CI is handled by GitHub Actions. release-please opens release PRs based on Conventional Commits and, once merged, publishes binaries and changelogs automatically. See Contributing for details on commit hygiene.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>Follow this guide to install babyctl, hook it up to Terraformer and kubectl, and run your first commands.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.20+ for building from source.</li> <li>kubectl in your <code>$PATH</code> for Kubernetes resource discovery.</li> <li>terraformer (optional but recommended) for Terraform provider discovery.</li> <li>A POSIX shell environment (macOS, Linux, or WSL2) with <code>make</code>.</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"Using makeUsing go install <p><pre><code>make install\n</code></pre> Installs the <code>babyctl</code> binary into <code>$GOBIN</code> (defaults to <code>$(go env GOPATH)/bin</code>).</p> <p><pre><code>go install ./cmd/babyctl\n</code></pre> Produces the same binary without invoking the Makefile helpers.</p> <p>After installing, ensure <code>$GOBIN</code> (or <code>$GOPATH/bin</code>) is on your <code>PATH</code>:</p> <pre><code>export PATH=\"$(go env GOPATH)/bin:$PATH\"\n</code></pre>"},{"location":"getting-started/#verifying-the-installation","title":"Verifying the installation","text":"<pre><code>babyctl version\nbabyctl api-resources | head\n</code></pre> <p>If Terraformer is present, you will see additional API groups (e.g. <code>terraformer.aws/v0.8.30</code>).</p>"},{"location":"getting-started/#bootstrapping-discovery-data","title":"Bootstrapping discovery data","text":"<p><code>babyctl api-resources</code> shells out to <code>kubectl</code> and Terraformer when available. To experiment without Terraformer you can use the sample discovery definitions that ship with the repo:</p> <pre><code>mkdir -p ~/.babyctl\ncp -r examples/api-definitions/apis ~/.babyctl/\n</code></pre> <p>This enables the API server integration and provides a richer dataset for demos.</p>"},{"location":"getting-started/#first-commands","title":"First commands","text":"<pre><code># List the merged resource catalog\nbabyctl api-resources\n\n# Filter for Terraformer resources\nbabyctl api-resources --source terraformer\n\n# Explain the schema for a resource\nbabyctl explain deployments\n\n# Convert between formats\nbabyctl convert -f terraform.tf -oyaml\n</code></pre>"},{"location":"getting-started/#applying-configuration","title":"Applying configuration","text":"<p><code>babyctl apply</code> intentionally mirrors kubectl:</p> <pre><code># Apply a manifest from disk\nbabyctl apply -f infrastructure.yaml\n\n# Apply from stdin (pairs well with Kustomize, Helm, or ytt)\nkustomize build overlays/prod | babyctl apply -f-\n</code></pre> <p>Use <code>babyctl diff</code> before applying to preview the impact and <code>babyctl edit</code> for quick emergency changes.</p>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Use <code>babyctl --help</code> or <code>babyctl &lt;command&gt; --help</code> to inspect flags.</li> <li>Run with <code>--v=4</code> (or higher) for verbose logs coming from Cobra and underlying helpers.</li> <li>When Terraformer resources are missing, confirm <code>terraformer</code> is installed and on your <code>PATH</code>.</li> <li>If the API server is not showing custom resources, ensure the files under <code>~/.babyctl/apis</code> are well-formed and restart   <code>babyctl api-server</code>.</li> </ul>"},{"location":"kubectl-integration/","title":"Testing babyctl API Server with kubectl","text":"<p>This guide shows how to use the babyctl API server with kubectl.</p>"},{"location":"kubectl-integration/#prerequisites","title":"Prerequisites","text":"<ul> <li>kubectl installed</li> <li>babyctl built and installed</li> <li>Example API definitions installed at <code>~/.babyctl/apis</code></li> </ul>"},{"location":"kubectl-integration/#setup","title":"Setup","text":"<ol> <li> <p>Install the example API definitions: <pre><code>mkdir -p ~/.babyctl\ncp -r examples/api-definitions/apis ~/.babyctl/\n</code></pre></p> </li> <li> <p>Start the API server: <pre><code>babyctl api-server --port 8080\n</code></pre></p> </li> </ol> <p>The server will start and listen on port 8080, serving API definitions from <code>~/.babyctl/apis</code>.</p>"},{"location":"kubectl-integration/#using-with-kubectl","title":"Using with kubectl","text":""},{"location":"kubectl-integration/#test-api-discovery","title":"Test API Discovery","text":"<pre><code># List all API groups\nkubectl --server=http://localhost:8080 api-resources\n\n# List all API versions\nkubectl --server=http://localhost:8080 api-versions\n</code></pre>"},{"location":"kubectl-integration/#expected-output","title":"Expected Output","text":"<p>When you run <code>kubectl --server=http://localhost:8080 api-resources</code>, you should see output similar to:</p> <pre><code>NAME                APIVERSION                          NAMESPACED   KIND\ndeployments         apps/v1                             true         Deployment\nstatefulsets        apps/v1                             true         StatefulSet\ndaemonsets          apps/v1                             true         DaemonSet\nreplicasets         apps/v1                             true         ReplicaSet\nrepositories        terraformer.github/v0.8.30          false        Repository\nteams               terraformer.github/v0.8.30          false        Team\nmembers             terraformer.github/v0.8.30          false        Member\norganization        terraformer.github/v0.8.30          false        Organization\ninstances           terraformer.aws/v0.8.30             false        Instance\nbuckets             terraformer.aws/v0.8.30             false        Bucket\nvpcs                terraformer.aws/v0.8.30             false        VPC\nsecuritygroups      terraformer.aws/v0.8.30             false        SecurityGroup\n</code></pre>"},{"location":"kubectl-integration/#testing-with-curl","title":"Testing with curl","text":"<p>You can also test the API directly with curl:</p> <pre><code># Get core API\ncurl http://localhost:8080/api\n\n# Get all API groups\ncurl http://localhost:8080/apis\n\n# Get resources in a specific group/version\ncurl http://localhost:8080/apis/apps/v1\ncurl http://localhost:8080/apis/terraformer.github/v0.8.30\n</code></pre>"},{"location":"kubectl-integration/#creating-custom-api-definitions","title":"Creating Custom API Definitions","text":"<p>You can create your own API definitions by adding YAML files to <code>~/.babyctl/apis</code>:</p> <ol> <li> <p>Create a directory structure: <pre><code>mkdir -p ~/.babyctl/apis/mygroup/v1\n</code></pre></p> </li> <li> <p>Create a <code>resources.yaml</code> file: <pre><code>kind: APIResourceList\napiVersion: v1\ngroupVersion: mygroup/v1\nresources:\n  - name: myresources\n    singularName: myresource\n    namespaced: true\n    kind: MyResource\n    verbs:\n      - get\n      - list\n      - create\n      - update\n      - delete\n    shortNames:\n      - mr\n    categories:\n      - all\n</code></pre></p> </li> <li> <p>Restart the API server to pick up the new definition</p> </li> <li> <p>Test with kubectl: <pre><code>kubectl --server=http://localhost:8080 api-resources | grep myresources\n</code></pre></p> </li> </ol>"},{"location":"kubectl-integration/#using-babyctl-commands","title":"Using babyctl Commands","text":"<p>You can also use babyctl commands while pointing at the API server:</p> <pre><code># Note: This will use the API server endpoints for discovery\nbabyctl --server=http://localhost:8080 api-resources\nbabyctl --server=http://localhost:8080 api-versions\n</code></pre>"},{"location":"kubectl-integration/#integration-with-kubeconfig","title":"Integration with kubeconfig","text":"<p>For easier use, you can add the API server to your kubeconfig:</p> <pre><code>kubectl config set-cluster babyctl-api --server=http://localhost:8080\nkubectl config set-context babyctl-api --cluster=babyctl-api\nkubectl config use-context babyctl-api\n</code></pre> <p>Then you can use kubectl without specifying the server each time:</p> <pre><code>kubectl api-resources\nkubectl api-versions\n</code></pre>"},{"location":"kubectl-integration/#notes","title":"Notes","text":"<ul> <li>The API server only implements the discovery endpoints (GET /api, GET /apis, GET /apis//) <li>It does not handle actual resource CRUD operations (get, create, update, delete)</li> <li>This is designed for API discovery and metadata purposes, not for managing actual resources</li> <li>For resource management, continue to use kubectl against a real Kubernetes cluster or babyctl for terraform resources</li>"},{"location":"workflows/","title":"Common workflows","text":"<p>Use these recipes to weave babyctl into your day-to-day operations.</p>"},{"location":"workflows/#bring-existing-infrastructure-under-control","title":"Bring existing infrastructure under control","text":"<ol> <li>Export the current definition using whatever tooling is available (Terraform state, cloud console export, etc.).</li> <li>Convert it to YAML if needed:    <pre><code>babyctl convert -f terraform.tfstate -oyaml &gt; imported.yaml\n</code></pre></li> <li>Review the manifest, trim any drift you want babyctl to own, and run:    <pre><code>babyctl apply -f imported.yaml\n</code></pre></li> <li>Repeat with <code>babyctl diff</code> until the declarative state matches reality.</li> </ol>"},{"location":"workflows/#manage-everything-through-overlays","title":"Manage everything through overlays","text":"<p>Use your existing Kustomize/Helm/ytt pipelines and pipe the rendered output into babyctl:</p> <pre><code>kustomize build overlays/prod | babyctl apply -f-\n</code></pre> <p>Pair <code>babyctl diff -f-</code> with the same pipeline to preview changes in CI before you deploy.</p>"},{"location":"workflows/#emergency-edits","title":"Emergency edits","text":"<p>When latency matters more than automation:</p> <pre><code>babyctl edit terraformer.aws.instance/my-production-instance\n</code></pre> <p>babyctl downloads the resource, opens <code>$EDITOR</code>, and applies the diff. Use <code>babyctl get &lt;resource&gt; -oyaml</code> afterwards to confirm that the update landed as expected.</p>"},{"location":"workflows/#convert-formats-for-hybrid-teams","title":"Convert formats for hybrid teams","text":"<pre><code># HCL -&gt; YAML\nbabyctl convert -f terraform.tf -oyaml &gt; infra.yaml\n\n# YAML -&gt; HCL\nbabyctl convert -f infra.yaml -ohcl &gt; terraform.tf\n</code></pre> <p>This enables GitOps teams that prefer YAML while still producing Terraform-friendly configuration.</p>"},{"location":"workflows/#expose-discovery-data-to-kubectl","title":"Expose discovery data to kubectl","text":"<ol> <li>Install the sample API definitions under <code>~/.babyctl/apis</code> as described in the getting started guide.</li> <li>Start the discovery server:    <pre><code>babyctl api-server --port 8080\n</code></pre></li> <li>Point kubectl at it:    <pre><code>kubectl config set-cluster babyctl-api --server=http://localhost:8080\nkubectl config set-context babyctl-api --cluster=babyctl-api\nkubectl config use-context babyctl-api\nkubectl api-resources\n</code></pre></li> </ol> <p>See the kubectl integration guide for more detail.</p>"},{"location":"workflows/#automate-with-cicd","title":"Automate with CI/CD","text":"<ul> <li>Run <code>babyctl diff</code> in pull requests to show proposed infrastructure changes.</li> <li>Use <code>babyctl apply</code> in a controlled environment (e.g. GitHub Actions job) once changes are approved.</li> <li>Leverage the release automation to ship binaries for consumers.</li> </ul>"}]}