{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"babyctl","text":"<p>If Terraform and kubectl had a baby, it would feel a lot like babyctl.</p> <p>Active development</p> <p>babyctl is rapidly evolving. Expect dragons, gremlins, and fast-moving feature work while the core experience stabilises.</p> <p>babyctl lets you interact with any infrastructure that Terraform can describe while keeping the ergonomics of kubectl. The goal is to provide <code>kubectl</code>-style workflows\u2014<code>get</code>, <code>apply</code>, <code>edit</code>, <code>diff</code>, and more\u2014without depending on a running Kubernetes cluster.</p>"},{"location":"#why-babyctl","title":"Why babyctl?","text":"<ul> <li>Zero-import applies \u2013 point <code>babyctl apply</code> at pre-existing infrastructure to bring it under control without painful Terraform imports.</li> <li>Unified discovery \u2013 <code>babyctl api-resources</code> merges Kubernetes and Terraformer API discovery into one familiar list.</li> <li>Multi-format fluency \u2013 switch between YAML, HCL, and JSON with a single flag when you need the view that makes sense.</li> <li>Crisis-friendly editing \u2013 <code>babyctl edit</code> opens live infrastructure in your editor so you can perform surgical changes just like you would with kubectl (starting with the bundled <code>Widget</code> sample).</li> <li>Kubernetes ecosystem compatible \u2013 pipe the output of tools such as Kustomize straight into <code>babyctl</code> to reuse all of your favourite config machinery.</li> </ul>"},{"location":"#key-use-cases","title":"Key use cases","text":"<ol> <li>Bring click-ops infrastructure under control</li> <li>Inspect resources with <code>babyctl get</code>.</li> <li>Run <code>babyctl apply -f existing.yaml</code> to adopt them without juggling Terraform state imports.</li> <li>Leverage Kubernetes tooling for Terraform resources</li> <li><code>kustomize build overlays/prod | babyctl apply -f -</code> works against anything Terraformer can reach.</li> <li>Emergency edits</li> <li>When production is on fire, open the resource directly via <code>babyctl edit</code> and keep the lights on. The first implementation targets the bundled <code>babyctl.dev/v1alpha1</code> <code>Widget</code> resource when using the local API definitions; more resources will follow.</li> <li>Format conversion</li> <li>Convert back and forth with <code>babyctl convert -f terraform.tf -oyaml</code> or <code>-ohcl</code>.</li> </ol>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code># Install babyctl\nmake install\n\n# Discover available resources from kubectl and Terraformer\nbabyctl api-resources\n\n# Apply configuration from stdin\nkustomize build overlays/dev | babyctl apply -f-\n\n# Convert Terraform to YAML\nbabyctl convert -f terraform.tf -oyaml\n</code></pre> <p>See the Getting Started guide for detailed setup steps.</p>"},{"location":"#supported-commands","title":"Supported commands","text":"Command Description <code>api-resources</code> List API resources available via kubectl and Terraformer <code>api-server</code> Run a Kubernetes-compatible discovery server backed by babyctl definitions <code>api-versions</code> Show supported API versions <code>apply</code> Apply a declarative configuration to a live resource <code>convert</code> Translate files between HCL, YAML, and JSON <code>delete</code> Delete live resources <code>diff</code> Compare live resources against would-be applies <code>edit</code> Open a resource in <code>$EDITOR</code> and persist edits live <code>explain</code> Display documentation about a resource <code>get</code> Retrieve one or many resources <code>version</code> Print client and server versions <p>For full flag details see the CLI reference.</p>"},{"location":"#release-automation","title":"Release automation","text":"<p>babyctl uses GitHub Actions and release-please to cut releases automatically. Follow Conventional Commits so release-please can determine semantic versions and changelog entries. See the contributing guide for details.</p>"},{"location":"#learn-more","title":"Learn more","text":"<ul> <li>Getting started</li> <li>Common workflows</li> <li>Kubectl integration</li> <li>Architecture deep dive</li> <li>Development workflow</li> </ul>"},{"location":"api-server-compatibility/","title":"API Server Compatibility Checklist","text":"<p>This document outlines what the current <code>babyctl api-server</code> already exposes and what still needs to be implemented before kubectl can treat it like a general-purpose Kubernetes API server.</p>"},{"location":"api-server-compatibility/#what-the-server-already-does","title":"What the server already does","text":"<ul> <li>Discovery endpoints plus sample CRUD \u2013 the HTTP router in <code>pkg/apiserver/server.go</code> wires up handlers for <code>GET /api</code>, <code>GET /apis</code>, and <code>GET /apis/&lt;group&gt;/&lt;version&gt;</code> plus two <code>babyctl</code>-specific helper routes for resource definitions and controllers. Cluster-scoped CRUD endpoints are now registered for any resource that exposes a REST controller (the bundled <code>babyctl.dev/v1alpha1/widgets</code> definition exercises <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>).</li> <li>File-backed resource metadata \u2013 API groups, versions, and resource lists are read from YAML files under <code>~/.babyctl/apis</code> (or <code>--api-path</code>) via the loader. This keeps discovery data in sync with whatever definitions you install locally.</li> <li>In-memory cache \u2013 the server preloads API resources at startup and filters out empty groups so kubectl\u2019s discovery calls only see definitions that also have controller implementations.</li> </ul> <p>These capabilities are sufficient for <code>kubectl api-resources</code> / <code>api-versions</code>, but kubectl requires more when you attempt <code>get</code>, <code>apply</code>, or other resource verbs.</p>"},{"location":"api-server-compatibility/#gaps-to-close-for-kubectl-compatibility","title":"Gaps to close for kubectl compatibility","text":"<ol> <li>Resource endpoints for each verb</li> <li>Cluster-scoped CRUD handlers exist for resources that include a REST controller (see the widgets sample), but namespaced URLs, collection deletes, and patch verbs are not implemented yet.</li> <li>The handlers must support namespaced URLs, subresources such as <code>/status</code>, and JSON Patch/Merge Patch (<code>PATCH</code> with the proper <code>Content-Type</code>).</li> <li> <p>Until these semantics are added kubectl will still fail when targeting built-in resources such as <code>deployments</code>.</p> </li> <li> <p>List/watch semantics </p> </li> <li><code>kubectl get</code> and the informer cache expect <code>list</code> plus <code>watch</code> verbs to stream events. Implement chunking, <code>resourceVersion</code>, <code>continue</code>, <code>labelSelector</code>, and <code>fieldSelector</code> query parameters so clients can paginate or resume watches.  </li> <li> <p>Watches require HTTP streaming with the Kubernetes watch event envelope (<code>{\"type\":\"ADDED\",\"object\":...}</code>).</p> </li> <li> <p>Object schemas and metadata </p> </li> <li>Responses need Kubernetes-style metadata fields (<code>apiVersion</code>, <code>kind</code>, <code>metadata.{name,namespace,uid,resourceVersion}</code>) for every resource.  </li> <li> <p>Consider generating OpenAPI (<code>/openapi/v2</code> or <code>/openapi/v3</code>) so kubectl can validate manifests.</p> </li> <li> <p>Status and scale subresources </p> </li> <li>Many built-in commands (<code>kubectl rollout status</code>, <code>kubectl scale</code>) rely on <code>/status</code> and <code>/scale</code>.  </li> <li> <p>Expose separate handlers that delegate to the underlying <code>resourceconfig.Controller</code> implementations or return \u201cmethod not allowed\u201d unless the definition explicitly supports them.</p> </li> <li> <p>Error handling and admission-style validation </p> </li> <li>Use Kubernetes API status responses (<code>Status</code> objects with <code>status</code>, <code>reason</code>, <code>message</code>, <code>code</code>).  </li> <li> <p>Validate request bodies and enforce optimistic concurrency via <code>metadata.resourceVersion</code> to match kubectl expectations for <code>update</code>/<code>patch</code>.</p> </li> <li> <p>Authentication, authorization, and TLS </p> </li> <li> <p>Real kubectl clients default to HTTPS with certificate verification. Add TLS flags (cert/key/CA) and optionally webhook-style authn/authz to avoid having to invoke <code>kubectl --server=http://... --insecure-skip-tls-verify</code>.</p> </li> <li> <p>Miscellaneous Kubernetes endpoints </p> </li> <li>Implement <code>/version</code>, <code>/readyz</code>, <code>/healthz</code>, and <code>/livez</code> so kubectl and tooling can perform health checks.  </li> <li> <p>Consider supporting <code>/.well-known/openid-configuration</code> if you later add token auth, because kubectl will call it when OIDC data is referenced in kubeconfig contexts.</p> </li> <li> <p>Dynamic reloading or informer refresh </p> </li> <li> <p>Today the loader only reads definitions at startup. Add file watchers or an admin endpoint to reload definitions so cluster admins don\u2019t have to restart the server when installing new APIs.</p> </li> <li> <p>Multi-user reliability </p> </li> <li>Add request logging, structured errors, and rate limiting.  </li> <li>Provide consistent concurrency guarantees for controllers so concurrent kubectl operations do not corrupt backing systems.</li> </ol> <p>Addressing the points above will move the server from \u201cdiscovery-only shim\u201d to something kubectl can treat like a full API server.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>babyctl mirrors the architectural approach used by kubectl so that contributors can reuse familiar patterns while extending the CLI to Terraform-managed infrastructure.</p>"},{"location":"architecture/#high-level-design","title":"High-level design","text":"<ul> <li>Cobra everywhere \u2013 each command is a <code>cobra.Command</code> registered from <code>pkg/cmd</code>. Commands own their flags, examples, and   validation logic.</li> <li>Passthrough-first implementation \u2013 most commands currently delegate to kubectl or Terraformer binaries. This keeps the UX   compatible while leaving room for native implementations later.</li> <li>Composable packages \u2013 helper libraries (printers, Terraformer helpers, API discovery) live under <code>pkg/</code> so they can be   reused by new commands or external tooling.</li> </ul>"},{"location":"architecture/#project-structure","title":"Project structure","text":"<pre><code>cmd/\n  babyctl/        # main.go creates the root command\npkg/\n  cmd/            # CLI command implementations\n  apiresources/   # Aggregates discovery information from kubectl + Terraformer\n  terraformer/    # Wrappers around the terraformer CLI\n  printers/       # Output helpers (tables, YAML/HCL conversion)\nexamples/\n  api-definitions # Sample discovery data served by the API server\n</code></pre> <p>Keep <code>main.go</code> minimal\u2014bootstrap logging, create the root command, and hand off to Cobra.</p>"},{"location":"architecture/#resource-discovery-pipeline","title":"Resource discovery pipeline","text":"<ol> <li><code>pkg/apiresources</code> shells out to <code>kubectl api-resources</code>.</li> <li><code>pkg/terraformer</code> introspects Terraformer providers and resources.</li> <li>Results are normalised into Kubernetes-style <code>APIResource</code> structs and merged.</li> <li>Commands such as <code>babyctl api-resources</code>, <code>babyctl api-versions</code>, and the discovery API server use this merged list.</li> </ol> <p>This pipeline enables familiar commands such as <code>kubectl api-resources</code> to show Terraform resources when pointed at the babyctl API server.</p>"},{"location":"architecture/#adding-a-command","title":"Adding a command","text":"<ol> <li>Create <code>pkg/cmd/&lt;name&gt;.go</code> returning a configured <code>*cobra.Command</code>.</li> <li>Wire the command up in <code>pkg/cmd/cmd.go</code> (or the relevant parent command) by calling the constructor.</li> <li>Keep business logic in helper packages so the command stays thin and testable.</li> <li>Add tests under <code>pkg/&lt;area&gt;</code> or integration tests under <code>test/</code> once they exist.</li> </ol> <p>Follow the same conventions as kubectl: short/long descriptions, <code>Examples</code> blocks, and logical flag groups.</p>"},{"location":"architecture/#api-server","title":"API server","text":"<p><code>babyctl api-server</code> exposes Kubernetes discovery endpoints only\u2014it does not implement CRUD. The server:</p> <ul> <li>Serves <code>/api</code> and <code>/apis</code> based on the merged discovery cache.</li> <li>Reads static definitions from <code>~/.babyctl/apis</code> so you can layer in your own groups/versions.</li> <li>Enables kubectl to target Terraform resources via <code>kubectl --server=http://localhost:8080 api-resources</code>.</li> </ul> <p>See kubectl integration for hands-on steps.</p>"},{"location":"architecture/#formatting-and-output","title":"Formatting and output","text":"<p>Printers under <code>pkg/printers</code> take care of rendering tables, YAML, JSON, or HCL. The <code>convert</code> command leans on these utilities to round-trip between formats so teams can choose the representation that fits their workflow.</p>"},{"location":"architecture/#testing-strategy","title":"Testing strategy","text":"<ul> <li>Unit tests live alongside packages (e.g. <code>pkg/apiresources/apiresources_test.go</code>).</li> <li>Integration tests use the <code>test-api-server.sh</code> helper or future suites under <code>test/</code> to validate CLI interactions.</li> <li>Run <code>make test</code> locally and rely on GitHub Actions for CI coverage.</li> </ul>"},{"location":"architecture/#key-dependencies","title":"Key dependencies","text":"<ul> <li>Cobra for command parsing.</li> <li>Terraformer for discovering Terraform resources.</li> <li>Standard Go libraries for HTTP, JSON, and file IO.</li> </ul> <p>Consult <code>ARCHITECTURE.md</code> for a more exhaustive blueprint when contributing major features.</p>"},{"location":"cli-reference/","title":"CLI reference","text":"<p>Every command is implemented with Cobra and mirrors the kubectl UX wherever possible. Use <code>babyctl &lt;command&gt; --help</code> for the authoritative flag list. This page summarises the intent and primary flags for each command.</p>"},{"location":"cli-reference/#global-flags","title":"Global flags","text":"<ul> <li><code>--server</code> \u2013 Override the API server to talk to (useful with <code>babyctl api-server</code>).</li> <li><code>--kubeconfig</code> \u2013 Provide a kubeconfig file when leveraging kubectl discovery.</li> <li><code>-o</code>, <code>--output</code> \u2013 Select table, yaml, json, or hcl output where supported.</li> <li><code>--source</code> \u2013 Limit discovery to <code>kubectl</code> or <code>terraformer</code> when running <code>api-resources</code>.</li> </ul>"},{"location":"cli-reference/#command-catalog","title":"Command catalog","text":""},{"location":"cli-reference/#api-resources","title":"api-resources","text":"<p>Lists all resources that babyctl can discover from kubectl and Terraformer.</p> <pre><code>babyctl api-resources [--source kubectl|terraformer]\n</code></pre>"},{"location":"cli-reference/#api-server","title":"api-server","text":"<p>Starts a lightweight discovery server that exposes <code>/api</code>, <code>/apis</code>, and <code>/apis/&lt;group&gt;/&lt;version&gt;</code> so that kubectl (or other clients) can discover the combined API surface. Pair with the kubectl integration guide.</p> <pre><code>babyctl api-server --port 8080\n\n# With CORS enabled for frontend applications\nbabyctl api-server --cors-allowed-origins=\"http://localhost:3000,https://example.com\"\n</code></pre>"},{"location":"cli-reference/#cors-support","title":"CORS Support","text":"<p>CORS (Cross-Origin Resource Sharing) can be enabled to allow frontend applications running on different origins to access the API server:</p> <ul> <li><code>--cors-allowed-origins</code> \u2013 Comma-separated list of allowed origins (e.g., <code>http://localhost:3000,https://example.com</code>). Use <code>*</code> to allow all origins.</li> <li><code>--cors-allowed-methods</code> \u2013 Comma-separated list of allowed HTTP methods (default: <code>GET, POST, PUT, DELETE, OPTIONS</code>)</li> <li><code>--cors-allowed-headers</code> \u2013 Comma-separated list of allowed headers (default: <code>Content-Type, Authorization</code>)</li> <li><code>--cors-allow-credentials</code> \u2013 Allow credentials (cookies, authorization headers) in CORS requests</li> </ul> <p>Example: <pre><code># Allow local development server\nbabyctl api-server --cors-allowed-origins=\"http://localhost:3000\"\n\n# Allow multiple domains with credentials\nbabyctl api-server \\\n  --cors-allowed-origins=\"https://app.example.com,https://dashboard.example.com\" \\\n  --cors-allow-credentials\n</code></pre></p>"},{"location":"cli-reference/#api-versions","title":"api-versions","text":"<p>Displays the API versions served by the local discovery cache.</p> <pre><code>babyctl api-versions\n</code></pre>"},{"location":"cli-reference/#apply","title":"apply","text":"<p>Applies a manifest to the target infrastructure, mirroring <code>kubectl apply</code> semantics.</p> <pre><code>babyctl apply -f infra.yaml\nbabyctl apply -f- &lt; manifest.yaml\n</code></pre> <p>Important flags:</p> <ul> <li><code>-f, --filename</code> \u2013 File, directory, or <code>-</code> for stdin.</li> <li><code>--dry-run</code> \u2013 Validate manifests without persisting changes.</li> <li><code>--force-conflicts</code> \u2013 Adopt resources even when the live state differs.</li> </ul>"},{"location":"cli-reference/#convert","title":"convert","text":"<p>Translates between file formats to enable round-trips with Terraform.</p> <pre><code>babyctl convert -f terraform.tf -oyaml\n</code></pre> <p>Use <code>-oyaml</code>, <code>-ojson</code>, or <code>-ohcl</code> to choose the destination format.</p>"},{"location":"cli-reference/#define","title":"define","text":"<p>Interactively scaffold a new API definition under your local <code>api-definitions</code> tree. The command writes an <code>APIResourceList</code> entry and controller stubs for <code>bash</code> or <code>awscli</code> backed resources so they are immediately discoverable by <code>babyctl get</code>, <code>describe</code>, and <code>explain</code>.</p> <pre><code>babyctl define gadgets --path examples/api-definitions/apis\n</code></pre>"},{"location":"cli-reference/#login","title":"login","text":"<p>Authenticates to AWS SSO-backed profiles discovered from your <code>~/.aws/config</code> (or <code>AWS_CONFIG_FILE</code>). The command shells out to <code>aws sso login</code>, skipping the AWS CLI invocation entirely when cached credentials are already valid for the chosen profile.</p> <pre><code>babyctl login\n</code></pre> <p>When multiple SSO profiles exist, babyctl shows an interactive arrow-key selector (with a numbered fallback for non-interactive terminals) so you can pick the profile to refresh.</p>"},{"location":"cli-reference/#delete","title":"delete","text":"<p>Deletes the specified resources.</p> <pre><code>babyctl delete -f infra.yaml\nbabyctl delete deployment/my-app\n</code></pre>"},{"location":"cli-reference/#diff","title":"diff","text":"<p>Shows the delta between live resources and the manifests that would be applied.</p> <pre><code>babyctl diff -f infra.yaml\n</code></pre>"},{"location":"cli-reference/#edit","title":"edit","text":"<p>Fetches a live resource, opens it in <code>$BABYCTL_EDITOR</code>, <code>$KUBE_EDITOR</code>, <code>$VISUAL</code>, or <code>$EDITOR</code> (in that order, falling back to <code>vi</code>), and applies the diff when you save and exit\u2014just like <code>kubectl edit</code>.</p> <p>Note</p> <p>The first implementation targets the bundled <code>babyctl.dev/v1alpha1</code> <code>Widget</code> resource when you run against the local API definitions (<code>--path</code>). Additional controllers will gain edit support as their REST interfaces are wired up.</p> <pre><code># Edit the sample widget live\nBABYCTL_EDITOR=\"vim\" babyctl edit --path examples/api-definitions/apis widget cli-demo\n</code></pre>"},{"location":"cli-reference/#explain","title":"explain","text":"<p>Prints schema information for a resource type.</p> <pre><code>babyctl explain terraformer.aws.vpc\n</code></pre>"},{"location":"cli-reference/#get","title":"get","text":"<p>Retrieves resources in table or structured formats. Use <code>babyctl get all</code> to print every discoverable resource in table output.</p> <pre><code>babyctl get deployments\nbabyctl get deployment/my-app -oyaml\nbabyctl get all\n</code></pre>"},{"location":"cli-reference/#version","title":"version","text":"<p>Displays the client version and, when applicable, the API server version.</p> <pre><code>babyctl version\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for helping improve babyctl! This guide explains expectations for contributors and maintainers.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of conduct","text":"<p>Be excellent to each other. Treat all community members with respect and empathy.</p>"},{"location":"contributing/#workflow","title":"Workflow","text":"<ol> <li>Fork the repository or create a feature branch.</li> <li>Make your changes with clear, focused commits.</li> <li>Add or update tests when behaviour changes.</li> <li>Run <code>make check</code> locally to ensure formatting, linting, and tests all pass.</li> <li>Open a pull request describing the change and referencing any related issues.</li> </ol>"},{"location":"contributing/#commit-messages","title":"Commit messages","text":"<p>babyctl uses Conventional Commits. Examples:</p> <pre><code>git commit -m \"fix: patch panic when provider list is empty\"\ngit commit -m \"feat: add diff command\"\ngit commit -m \"feat!: redesign apply flow\\n\\nBREAKING CHANGE: requires explicit provider\"\n</code></pre> <p>Following this format allows release-please to determine semantic version bumps automatically.</p>"},{"location":"contributing/#review-checklist","title":"Review checklist","text":"<ul> <li>[ ] Code is formatted with <code>go fmt</code>.</li> <li>[ ] Tests pass locally (<code>make test</code>).</li> <li>[ ] User-facing changes are documented under <code>docs/</code>.</li> <li>[ ] New commands include helpful examples in <code>Examples</code> blocks.</li> <li>[ ] CLI output changes are covered by tests or manually verified screenshots/logs.</li> </ul>"},{"location":"contributing/#release-workflow","title":"Release workflow","text":"<p>Releases are driven by release-please:</p> <ol> <li>Merge changes into <code>main</code> using Conventional Commits.</li> <li>release-please opens or updates a release PR when it detects new commits.</li> <li>Once the release PR is merged, GitHub Actions publishes binaries (linux/darwin/windows for amd64+arm64), SHA256 checksums, and auto-generated changelog entries.</li> </ol>"},{"location":"contributing/#documentation-site","title":"Documentation site","text":"<p>Docs live under <code>docs/</code> and are rendered with MkDocs Material.</p> <pre><code>pip install mkdocs-material\nmkdocs serve\n</code></pre> <p>This spins up a live-reloading dev server at <code>http://127.0.0.1:8000</code>. Submit doc updates alongside code changes whenever possible.</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Open an issue or start a discussion on GitHub. We're excited to see what you build!</p>"},{"location":"development/","title":"Development workflow","text":""},{"location":"development/#toolchain","title":"Toolchain","text":"<ul> <li>Go 1.20+</li> <li>make</li> <li>golangci-lint (optional but recommended)</li> <li>Terraformer + kubectl for manual testing</li> </ul>"},{"location":"development/#common-tasks","title":"Common tasks","text":"<pre><code># Format code\ngo fmt ./...\n\n# Lint\ngo vet ./...\n\n# Run unit tests\nmake test\n\n# Run the whole suite (fmt + lint + test)\nmake check\n\n# Build the CLI\nmake build\n\n# Clean build artifacts\nmake clean\n</code></pre>"},{"location":"development/#running-the-api-server-locally","title":"Running the API server locally","text":"<pre><code>mkdir -p ~/.babyctl\ncp -r examples/api-definitions/apis ~/.babyctl/\n\nbabyctl api-server --port 8080\n</code></pre> <p>You can now point kubectl at <code>http://localhost:8080</code> as described in the kubectl integration guide.</p>"},{"location":"development/#repository-layout","title":"Repository layout","text":"<ul> <li><code>cmd/babyctl</code> \u2013 main entry point. Keep it thin.</li> <li><code>pkg/cmd</code> \u2013 home of all Cobra commands. Add a new file per command and register it with the root command.</li> <li><code>pkg/apiresources</code> \u2013 collects resource info from kubectl + Terraformer.</li> <li><code>pkg/terraformer</code> \u2013 helper functions for shelling out to Terraformer.</li> <li><code>pkg/printers</code> \u2013 output helpers shared by <code>get</code>, <code>apply</code>, and <code>convert</code>.</li> <li><code>examples/</code> \u2013 sample API definitions for demos and integration tests.</li> </ul>"},{"location":"development/#testing-tips","title":"Testing tips","text":"<ul> <li>Unit test packages in isolation where possible. For CLI behaviour, test the helper functions that power commands instead of the   Cobra plumbing.</li> <li>Use the provided <code>test-api-server.sh</code> script to exercise discovery endpoints end-to-end.</li> <li>Validate HCL/YAML conversions with golden files to catch formatting regressions.</li> </ul>"},{"location":"development/#releasing","title":"Releasing","text":"<p>CI is handled by GitHub Actions. release-please opens release PRs based on Conventional Commits and, once merged, publishes binaries and changelogs automatically. See Contributing for details on commit hygiene.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>Follow this guide to install babyctl, hook it up to Terraformer and kubectl, and run your first commands.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.20+ for building from source.</li> <li>kubectl in your <code>$PATH</code> for Kubernetes resource discovery.</li> <li>terraformer (optional but recommended) for Terraform provider discovery.</li> <li>A POSIX shell environment (macOS, Linux, or WSL2) with <code>make</code>.</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"Using makeUsing go install <p><pre><code>make install\n</code></pre> Installs the <code>babyctl</code> binary into <code>$GOBIN</code> (defaults to <code>$(go env GOPATH)/bin</code>).</p> <p><pre><code>go install ./cmd/babyctl\n</code></pre> Produces the same binary without invoking the Makefile helpers.</p> <p>After installing, ensure <code>$GOBIN</code> (or <code>$GOPATH/bin</code>) is on your <code>PATH</code>:</p> <pre><code>export PATH=\"$(go env GOPATH)/bin:$PATH\"\n</code></pre>"},{"location":"getting-started/#verifying-the-installation","title":"Verifying the installation","text":"<pre><code>babyctl version\nbabyctl api-resources | head\n</code></pre> <p>If Terraformer is present, you will see additional API groups (e.g. <code>terraformer.aws/v0.8.30</code>).</p>"},{"location":"getting-started/#bootstrapping-discovery-data","title":"Bootstrapping discovery data","text":"<p><code>babyctl api-resources</code> shells out to <code>kubectl</code> and Terraformer when available. To experiment without Terraformer you can use the sample discovery definitions that ship with the repo:</p> <pre><code>mkdir -p ~/.babyctl\ncp -r examples/api-definitions/apis ~/.babyctl/\n</code></pre> <p>This enables the API server integration and provides a richer dataset for demos.</p>"},{"location":"getting-started/#first-commands","title":"First commands","text":"<pre><code># List the merged resource catalog\nbabyctl api-resources\n\n# Filter for Terraformer resources\nbabyctl api-resources --source terraformer\n\n# Explain the schema for a resource\nbabyctl explain deployments\n\n# Convert between formats\nbabyctl convert -f terraform.tf -oyaml\n</code></pre>"},{"location":"getting-started/#applying-configuration","title":"Applying configuration","text":"<p><code>babyctl apply</code> intentionally mirrors kubectl:</p> <pre><code># Apply a manifest from disk\nbabyctl apply -f infrastructure.yaml\n\n# Apply from stdin (pairs well with Kustomize, Helm, or ytt)\nkustomize build overlays/prod | babyctl apply -f-\n</code></pre> <p>Use <code>babyctl diff</code> before applying to preview the impact and <code>babyctl edit</code> for quick emergency changes. The current implementation targets the bundled <code>babyctl.dev/v1alpha1</code> <code>Widget</code> resource when you run against the local API definitions (<code>--path</code>), and it honours <code>$BABYCTL_EDITOR</code>, <code>$KUBE_EDITOR</code>, <code>$VISUAL</code>, and <code>$EDITOR</code> (defaulting to <code>vi</code>).</p>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Use <code>babyctl --help</code> or <code>babyctl &lt;command&gt; --help</code> to inspect flags.</li> <li>Run with <code>--v=4</code> (or higher) for verbose logs coming from Cobra and underlying helpers.</li> <li>When Terraformer resources are missing, confirm <code>terraformer</code> is installed and on your <code>PATH</code>.</li> <li>If the API server is not showing custom resources, ensure the files under <code>~/.babyctl/apis</code> are well-formed and restart   <code>babyctl api-server</code>.</li> </ul>"},{"location":"kubectl-integration/","title":"Testing babyctl API Server with kubectl","text":"<p>This guide shows how to use the babyctl API server with kubectl.</p>"},{"location":"kubectl-integration/#prerequisites","title":"Prerequisites","text":"<ul> <li>kubectl installed</li> <li>babyctl built and installed</li> <li>Example API definitions installed at <code>~/.babyctl/apis</code></li> </ul>"},{"location":"kubectl-integration/#setup","title":"Setup","text":"<ol> <li> <p>Install the example API definitions (they mirror what the integration tests use in <code>examples/api-definitions/apis</code>): <pre><code>mkdir -p ~/.babyctl\ncp -r examples/api-definitions/apis ~/.babyctl/\n</code></pre></p> </li> <li> <p>Start the API server (the <code>--api-path</code> flag can point to any directory that contains the same layout): <pre><code>babyctl api-server --port 8080\n</code></pre></p> </li> </ol> <p>The server will start and listen on port 8080, serving API definitions from <code>~/.babyctl/apis</code>.</p> <ol> <li>(Optional) Run the smoke test script to make sure discovery works end-to-end: <pre><code>./test-api-server.sh\n</code></pre> The script starts the server in the background, runs <code>kubectl api-resources</code>, and tears the process down automatically.</li> </ol> <p>If you want to mirror the CRUD portion of the test suite manually, apply the sample Widget manifest the script exercises:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl --server=http://localhost:8080 apply -f -\napiVersion: babyctl.dev/v1alpha1\nkind: Widget\nmetadata:\n  name: smoke-test\nspec:\n  color: blue\n  size: small\nEOF\n</code></pre> <p>You can then <code>kubectl get widgets</code> or <code>kubectl delete widget smoke-test</code> to finish the lifecycle.</p>"},{"location":"kubectl-integration/#using-with-kubectl","title":"Using with kubectl","text":""},{"location":"kubectl-integration/#test-api-discovery","title":"Test API Discovery","text":"<pre><code># List all API groups\nkubectl --server=http://localhost:8080 api-resources\n\n# List all API versions\nkubectl --server=http://localhost:8080 api-versions\n</code></pre>"},{"location":"kubectl-integration/#validate-raw-discovery-responses","title":"Validate raw discovery responses","text":"<p>When debugging it is often useful to inspect the JSON payloads directly:</p> <pre><code># Core group\nkubectl --server=http://localhost:8080 get --raw /api | jq\n\n# All named groups\nkubectl --server=http://localhost:8080 get --raw /apis | jq\n\n# One specific group/version\nkubectl --server=http://localhost:8080 get --raw /apis/apps/v1 | jq\n</code></pre>"},{"location":"kubectl-integration/#try-the-sample-widgets-resource","title":"Try the sample Widgets resource","text":"<p>The bundled <code>babyctl.dev/v1alpha1</code> group now ships with a <code>Widget</code> resource driven by bash controllers that store JSON files under <code>examples/api-definitions/state/widgets</code>. You can exercise all CRUD verbs straight from kubectl:</p> <pre><code>cat &lt;&lt;'EOF' &gt; widget.yaml\napiVersion: babyctl.dev/v1alpha1\nkind: Widget\nmetadata:\n  name: demo\nspec:\n  color: blue\n  size: small\nEOF\n\nkubectl --server=http://localhost:8080 apply -f widget.yaml\nkubectl --server=http://localhost:8080 get widgets\nkubectl --server=http://localhost:8080 get widget demo -o yaml\nkubectl --server=http://localhost:8080 delete widget demo\n</code></pre>"},{"location":"kubectl-integration/#expected-output","title":"Expected Output","text":"<p>When you run <code>kubectl --server=http://localhost:8080 api-resources</code>, you should see output similar to:</p> <pre><code>NAME                APIVERSION                          NAMESPACED   KIND\ndeployments         apps/v1                             true         Deployment\nstatefulsets        apps/v1                             true         StatefulSet\ndaemonsets          apps/v1                             true         DaemonSet\nreplicasets         apps/v1                             true         ReplicaSet\nrepositories        terraformer.github/v0.8.30          false        Repository\nteams               terraformer.github/v0.8.30          false        Team\nmembers             terraformer.github/v0.8.30          false        Member\norganization        terraformer.github/v0.8.30          false        Organization\ninstances           terraformer.aws/v0.8.30             false        Instance\nbuckets             terraformer.aws/v0.8.30             false        Bucket\nvpcs                terraformer.aws/v0.8.30             false        VPC\nsecuritygroups      terraformer.aws/v0.8.30             false        SecurityGroup\n</code></pre>"},{"location":"kubectl-integration/#testing-with-curl","title":"Testing with curl","text":"<p>You can also test the API directly with curl:</p> <pre><code># Get core API\ncurl http://localhost:8080/api\n\n# Get all API groups\ncurl http://localhost:8080/apis\n\n# Get resources in a specific group/version\ncurl http://localhost:8080/apis/apps/v1\ncurl http://localhost:8080/apis/terraformer.github/v0.8.30\n</code></pre>"},{"location":"kubectl-integration/#creating-custom-api-definitions","title":"Creating Custom API Definitions","text":"<p>You can create your own API definitions by adding YAML files to <code>~/.babyctl/apis</code>:</p> <ol> <li> <p>Create a directory structure: <pre><code>mkdir -p ~/.babyctl/apis/mygroup/v1\n</code></pre></p> </li> <li> <p>Create a <code>resources.yaml</code> file: <pre><code>kind: APIResourceList\napiVersion: v1\ngroupVersion: mygroup/v1\nresources:\n  - name: myresources\n    singularName: myresource\n    namespaced: true\n    kind: MyResource\n    verbs:\n      - get\n      - list\n      - create\n      - update\n      - delete\n    shortNames:\n      - mr\n    categories:\n      - all\n</code></pre></p> </li> <li> <p>Restart the API server to pick up the new definition</p> </li> <li> <p>Test with kubectl: <pre><code>kubectl --server=http://localhost:8080 api-resources | grep myresources\n</code></pre></p> </li> </ol>"},{"location":"kubectl-integration/#using-babyctl-commands","title":"Using babyctl Commands","text":"<p>You can also use babyctl commands while pointing at the API server:</p> <pre><code># Note: This will use the API server endpoints for discovery\nbabyctl --server=http://localhost:8080 api-resources\nbabyctl --server=http://localhost:8080 api-versions\n</code></pre>"},{"location":"kubectl-integration/#integration-with-kubeconfig","title":"Integration with kubeconfig","text":"<p>For easier use, you can add the API server to your kubeconfig:</p> <pre><code>kubectl config set-cluster babyctl-api --server=http://localhost:8080\nkubectl config set-context babyctl-api --cluster=babyctl-api\nkubectl config use-context babyctl-api\n</code></pre> <p>Then you can use kubectl without specifying the server each time:</p> <pre><code>kubectl api-resources\nkubectl api-versions\n</code></pre>"},{"location":"kubectl-integration/#notes","title":"Notes","text":"<ul> <li>The API server only implements the discovery endpoints (GET /api, GET /apis, GET /apis//) <li>It does not handle actual resource CRUD operations (get, create, update, delete)</li> <li>This is designed for API discovery and metadata purposes, not for managing actual resources</li> <li>For resource management, continue to use kubectl against a real Kubernetes cluster or babyctl for terraform resources</li>"},{"location":"kubectl-integration/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Empty discovery output \u2013 check that the server logged \u201cAPI definitions loaded from \u2026\u201d without errors and that <code>~/.babyctl/apis</code> contains at least one <code>resources.yaml</code> file. Missing directories cause the CLI to print a warning at startup and kubectl will return no resources.</li> <li>kubectl refuses HTTP \u2013 by default kubectl prefers HTTPS. Supplying <code>--server=http://localhost:8080</code> (as shown above) forces it to use HTTP. If you want a kubeconfig entry instead, ensure <code>server: http://localhost:8080</code> is set for the context you activate.</li> <li>Port already in use \u2013 pass <code>--port &lt;number&gt;</code> when launching <code>babyctl api-server</code> to bind to a different TCP port, and update your kubectl commands accordingly.</li> </ul>"},{"location":"workflows/","title":"Common workflows","text":"<p>Use these recipes to weave babyctl into your day-to-day operations.</p>"},{"location":"workflows/#bring-existing-infrastructure-under-control","title":"Bring existing infrastructure under control","text":"<ol> <li>Export the current definition using whatever tooling is available (Terraform state, cloud console export, etc.).</li> <li>Convert it to YAML if needed:    <pre><code>babyctl convert -f terraform.tfstate -oyaml &gt; imported.yaml\n</code></pre></li> <li>Review the manifest, trim any drift you want babyctl to own, and run:    <pre><code>babyctl apply -f imported.yaml\n</code></pre></li> <li>Repeat with <code>babyctl diff</code> until the declarative state matches reality.</li> </ol>"},{"location":"workflows/#manage-everything-through-overlays","title":"Manage everything through overlays","text":"<p>Use your existing Kustomize/Helm/ytt pipelines and pipe the rendered output into babyctl:</p> <pre><code>kustomize build overlays/prod | babyctl apply -f-\n</code></pre> <p>Pair <code>babyctl diff -f-</code> with the same pipeline to preview changes in CI before you deploy.</p>"},{"location":"workflows/#emergency-edits","title":"Emergency edits","text":"<p>When latency matters more than automation:</p> <pre><code>BABYCTL_EDITOR=\"vim\" babyctl edit --path examples/api-definitions/apis widget cli-demo\n</code></pre> <p>babyctl downloads the resource, opens <code>$BABYCTL_EDITOR</code> (falling back through <code>$KUBE_EDITOR</code>, <code>$VISUAL</code>, <code>$EDITOR</code>, and finally <code>vi</code>), and applies the diff. Use <code>babyctl get &lt;resource&gt; -oyaml</code> afterwards to confirm that the update landed as expected. The initial implementation focuses on the bundled <code>babyctl.dev/v1alpha1</code> <code>Widget</code> resource when you run against the local API definitions.</p>"},{"location":"workflows/#convert-formats-for-hybrid-teams","title":"Convert formats for hybrid teams","text":"<pre><code># HCL -&gt; YAML\nbabyctl convert -f terraform.tf -oyaml &gt; infra.yaml\n\n# YAML -&gt; HCL\nbabyctl convert -f infra.yaml -ohcl &gt; terraform.tf\n</code></pre> <p>This enables GitOps teams that prefer YAML while still producing Terraform-friendly configuration.</p>"},{"location":"workflows/#expose-discovery-data-to-kubectl","title":"Expose discovery data to kubectl","text":"<ol> <li>Install the sample API definitions under <code>~/.babyctl/apis</code> as described in the getting started guide.</li> <li>Start the discovery server:    <pre><code>babyctl api-server --port 8080\n</code></pre></li> <li>Point kubectl at it:    <pre><code>kubectl config set-cluster babyctl-api --server=http://localhost:8080\nkubectl config set-context babyctl-api --cluster=babyctl-api\nkubectl config use-context babyctl-api\nkubectl api-resources\n</code></pre></li> </ol> <p>See the kubectl integration guide for more detail.</p>"},{"location":"workflows/#automate-with-cicd","title":"Automate with CI/CD","text":"<ul> <li>Run <code>babyctl diff</code> in pull requests to show proposed infrastructure changes.</li> <li>Use <code>babyctl apply</code> in a controlled environment (e.g. GitHub Actions job) once changes are approved.</li> <li>Leverage the release automation to ship binaries for consumers.</li> </ul>"},{"location":"reference/","title":"Provider Reference Overview","text":"<p>The reference documentation mirrors the experience you get on the official Terraform registry: every provider is grouped by API version, each resource shows the required and optional arguments, and you can pivot between YAML and HCL snippets via tabs.</p> <p>Info</p> <p>These pages are generated from the API definitions in <code>examples/api-definitions/apis</code>. Edit the YAML files there when you need to tweak a description, add a new field, or contribute a fresh example.</p>"},{"location":"reference/#updating-the-generated-pages","title":"Updating the generated pages","text":"<p>Run the doc generator any time an API definition changes:</p> <pre><code>make docs-reference\n</code></pre> <p>The command reads every <code>resources.yaml</code> file, loads the accompanying resource configuration (including the new <code>documentation</code> blocks), and writes Markdown files to <code>docs/reference/providers</code>. The MkDocs configuration then renders those files as part of the static site.</p>"},{"location":"reference/#authoring-tips","title":"Authoring tips","text":"<ul> <li>Keep YAML and HCL examples semantically equivalent so readers can copy either   without surprises.</li> <li>Focus descriptions on how babyctl users interact with the resource instead of   restating Terraform documentation word-for-word.</li> <li>Required and optional arguments live under the same <code>documentation.arguments</code>   array\u2014set <code>required: true</code> to have docgen automatically place the field in the   correct table.</li> </ul>"},{"location":"reference/providers/aws/","title":"AWS Provider Reference","text":""},{"location":"reference/providers/aws/#aws-provider-reference","title":"AWS Provider Reference","text":"<p>Source of truth</p> <p>Definitions live under <code>examples/api-definitions/apis/aws</code>. Update the API definitions and re-run <code>make docs-reference</code>.</p>"},{"location":"reference/providers/aws/#v1","title":"v1","text":"Resource Kind Short Names Categories <code>airflowenvironments</code> <code>AirflowEnvironment</code> afw \u2014 <code>autoscalinggroups</code> <code>AutoScalingGroup</code> asg \u2014 <code>ec2instances</code> <code>EC2Instance</code> ec2 \u2014 <code>ecrrepositories</code> <code>ECRRepository</code> ecr \u2014 <code>ecsclusters</code> <code>ECSCluster</code> ecsc \u2014 <code>elasticacheinstances</code> <code>ElastiCacheInstance</code> eci \u2014 <code>firehosedeliverystreams</code> <code>FirehoseDeliveryStream</code> fhs \u2014 <code>kafkaclusters</code> <code>KafkaCluster</code> kfk \u2014 <code>kinesisstreams</code> <code>KinesisStream</code> kis \u2014 <code>lambdafunctions</code> <code>LambdaFunction</code> lambda \u2014 <code>natgateways</code> <code>NATGateway</code> nat \u2014 <code>opensearchdomains</code> <code>OpenSearchDomain</code> osd \u2014 <code>rdsinstances</code> <code>RDSInstance</code> rds \u2014 <code>s3buckets</code> <code>S3Bucket</code> s3 \u2014 <code>transferservers</code> <code>TransferServer</code> trf \u2014"},{"location":"reference/providers/aws/#ec2instance","title":"EC2Instance","text":"<ul> <li>API Group: <code>aws/v1</code>\\</li> <li>Resource Name: <code>ec2instances</code>\\</li> <li>Kind: <code>EC2Instance</code></li> </ul> <p>Elastic compute optimized for long-running workloads.</p> <p><code>EC2Instance</code> resources let you describe or reconcile individual EC2 instances with the familiar <code>metadata</code>/<code>spec</code> shape. You can adopt existing instances with <code>babyctl get</code> and feed the object back into <code>babyctl apply</code> to update user data, networking, or tagging details without writing Terraform from scratch.</p>"},{"location":"reference/providers/aws/#configuration-examples","title":"Configuration Examples","text":"YAMLHCL <pre><code>apiVersion: aws/v1\nkind: EC2Instance\nmetadata:\n  name: web-01\nspec:\n  ami: ami-0fd123456\n  instanceType: t3.micro\n  subnetId: subnet-1234abcd\n  securityGroupIds:\n    - sg-web\n  keyName: admin\n  userData: |\n    #!/bin/bash\n    yum install -y nginx\n  tags:\n    Environment: production\n    Service: web\n</code></pre> <pre><code>resource \"aws_instance\" \"web\" {\n  ami           = \"ami-0fd123456\"\n  instance_type = \"t3.micro\"\n  subnet_id     = \"subnet-1234abcd\"\n  vpc_security_group_ids = [\n    aws_security_group.web.id,\n  ]\n  key_name  = \"admin\"\n  user_data = file(\"cloud-init/userdata.sh\")\n\n  tags = {\n    Environment = \"production\"\n    Service     = \"web\"\n  }\n}\n</code></pre>"},{"location":"reference/providers/aws/#required-arguments","title":"Required Arguments","text":"Name Type Description <code>ami</code> <code>string</code> ID of the AMI that should back the instance. <code>instanceType</code> <code>string</code> EC2 instance type, for example <code>t3.micro</code>."},{"location":"reference/providers/aws/#optional-arguments","title":"Optional Arguments","text":"Name Type Description Default <code>subnetId</code> <code>string</code> Subnet where the instance should run. \u2014 <code>securityGroupIds</code> <code>list(string)</code> Security groups that should be attached to the ENI. \u2014 <code>keyName</code> <code>string</code> SSH key pair to attach for console access. \u2014 <code>userData</code> <code>string</code> Cloud-init or shell user data rendered as base64. \u2014 <code>tags</code> <code>map(string)</code> Free-form tags that should be synced to the instance. \u2014"},{"location":"reference/providers/aws/#computed-attributes","title":"Computed Attributes","text":"Name Type Description <code>instanceId</code> <code>string</code> AWS-generated instance identifier. <code>privateIp</code> <code>string</code> Primary RFC1918 address associated with the instance. <code>publicIp</code> <code>string</code> Elastic or public IP (when applicable)."},{"location":"reference/providers/aws/#ecrrepository","title":"ECRRepository","text":"<ul> <li>API Group: <code>aws/v1</code>\\</li> <li>Resource Name: <code>ecrrepositories</code>\\</li> <li>Kind: <code>ECRRepository</code></li> </ul> <p>Private container image distribution.</p> <p>The <code>ECRRepository</code> resource mirrors the knobs you would typically set in Terraform when defining an AWS Elastic Container Registry. Use it to standardise repository encryption, immutability, lifecycle rules, and naming conventions across accounts.</p>"},{"location":"reference/providers/aws/#configuration-examples_1","title":"Configuration Examples","text":"YAMLHCL <pre><code>apiVersion: aws/v1\nkind: ECRRepository\nmetadata:\n  name: platform-images\nspec:\n  repositoryName: platform-images\n  imageTagMutability: IMMUTABLE\n  encryptionConfiguration:\n    type: KMS\n    kmsKeyArn: arn:aws:kms:ap-southeast-2:123456789012:key/abcd\n  scanOnPush: true\n  lifecyclePolicies:\n    - description: Keep last 30 prod tags\n      rulePriority: 1\n      selection:\n        tagStatus: tagged\n        tagPrefixList: [prod-]\n        countType: imageCountMoreThan\n        countNumber: 30\n      action:\n        type: expire\n</code></pre> <pre><code>resource \"aws_ecr_repository\" \"platform\" {\n  name                 = \"platform-images\"\n  image_tag_mutability = \"IMMUTABLE\"\n\n  encryption_configuration {\n    encryption_type = \"KMS\"\n    kms_key         = \"arn:aws:kms:ap-southeast-2:123456789012:key/abcd\"\n  }\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"platform\" {\n  repository = aws_ecr_repository.platform.name\n  policy = jsonencode({\n    rules = [{\n      description = \"Keep last 30 prod tags\"\n      rulePriority = 1\n      selection = {\n        tagStatus     = \"tagged\"\n        tagPrefixList = [\"prod-\"]\n        countType     = \"imageCountMoreThan\"\n        countNumber   = 30\n      }\n      action = { type = \"expire\" }\n    }]\n  })\n}\n</code></pre>"},{"location":"reference/providers/aws/#required-arguments_1","title":"Required Arguments","text":"Name Type Description <code>repositoryName</code> <code>string</code> Human-friendly name for the repository."},{"location":"reference/providers/aws/#optional-arguments_1","title":"Optional Arguments","text":"Name Type Description Default <code>imageTagMutability</code> <code>string</code> Whether tags are <code>MUTABLE</code> or <code>IMMUTABLE</code>. \u2014 <code>scanOnPush</code> <code>bool</code> Enables ECR vulnerability scanning when images are pushed. \u2014 <code>encryptionConfiguration</code> <code>object</code> Optional block specifying KMS encryption details. \u2014 <code>lifecyclePolicies</code> <code>list(object)</code> Ordered list of lifecycle policies expressed as JSON-friendly maps. \u2014"},{"location":"reference/providers/aws/#computed-attributes_1","title":"Computed Attributes","text":"Name Type Description <code>repositoryArn</code> <code>string</code> ARN that uniquely identifies the repository. <code>repositoryUri</code> <code>string</code> URI that docker clients can push to."},{"location":"reference/providers/aws/#lambdafunction","title":"LambdaFunction","text":"<ul> <li>API Group: <code>aws/v1</code>\\</li> <li>Resource Name: <code>lambdafunctions</code>\\</li> <li>Kind: <code>LambdaFunction</code></li> </ul> <p>Event-driven serverless compute with millisecond billing.</p> <p><code>LambdaFunction</code> resources bring AWS Lambda into the same document-driven workflow as other providers. Use them to keep runtime, IAM role, package sources, and tuning flags aligned between HCL and YAML consumers.</p>"},{"location":"reference/providers/aws/#configuration-examples_2","title":"Configuration Examples","text":"YAMLHCL <pre><code>apiVersion: aws/v1\nkind: LambdaFunction\nmetadata:\n  name: image-processor\nspec:\n  functionName: image-processor\n  runtime: nodejs20.x\n  handler: handler.run\n  roleArn: arn:aws:iam::123456789012:role/lambda-runtime\n  package:\n    s3Bucket: artifacts-us-east-1\n    s3Key: lambdas/image-processor.zip\n  timeoutSeconds: 30\n  memoryMB: 512\n  environment:\n    LOG_LEVEL: info\n    BUCKET_NAME: raw-images\n</code></pre> <pre><code>resource \"aws_lambda_function\" \"image_processor\" {\n  function_name = \"image-processor\"\n  handler       = \"handler.run\"\n  role          = \"arn:aws:iam::123456789012:role/lambda-runtime\"\n  runtime       = \"nodejs20.x\"\n  s3_bucket     = \"artifacts-us-east-1\"\n  s3_key        = \"lambdas/image-processor.zip\"\n  timeout       = 30\n  memory_size   = 512\n\n  environment {\n    variables = {\n      LOG_LEVEL   = \"info\"\n      BUCKET_NAME = \"raw-images\"\n    }\n  }\n}\n</code></pre>"},{"location":"reference/providers/aws/#required-arguments_2","title":"Required Arguments","text":"Name Type Description <code>functionName</code> <code>string</code> Friendly name for the Lambda function. <code>runtime</code> <code>string</code> Runtime identifier such as <code>nodejs20.x</code> or <code>python3.12</code>. <code>handler</code> <code>string</code> Entrypoint format <code>&lt;file&gt;.&lt;export&gt;</code> evaluated by the runtime. <code>roleArn</code> <code>string</code> IAM role ARN that provides execution permissions. <code>package</code> <code>object</code> Location of the deployment artifact (S3 bucket/key or container image)."},{"location":"reference/providers/aws/#optional-arguments_2","title":"Optional Arguments","text":"Name Type Description Default <code>timeoutSeconds</code> <code>number</code> Max invocation time before Lambda terminates (default 3). \u2014 <code>memoryMB</code> <code>number</code> Memory size in MB that also controls CPU share. \u2014 <code>environment</code> <code>map(string)</code> Key/value environment variables available during execution. \u2014"},{"location":"reference/providers/aws/#computed-attributes_2","title":"Computed Attributes","text":"Name Type Description <code>functionArn</code> <code>string</code> Full ARN of the Lambda function. <code>lastModified</code> <code>string</code> Timestamp of the most recent publish or update."},{"location":"reference/providers/az/","title":"Azure Provider Reference","text":""},{"location":"reference/providers/az/#azure-provider-reference","title":"Azure Provider Reference","text":"<p>Source of truth</p> <p>Definitions live under <code>examples/api-definitions/apis/az</code>. Update the API definitions and re-run <code>make docs-reference</code>.</p>"},{"location":"reference/providers/az/#v1","title":"v1","text":"Resource Kind Short Names Categories <code>containerregistries</code> <code>ContainerRegistry</code> acr \u2014 <code>functionapps</code> <code>FunctionApp</code> func \u2014 <code>storageaccount</code> <code>StorageAccount</code> sa \u2014 <code>virtualmachines</code> <code>VirtualMachine</code> vm \u2014"},{"location":"reference/providers/az/#containerregistry","title":"ContainerRegistry","text":"<ul> <li>API Group: <code>az/v1</code>\\</li> <li>Resource Name: <code>containerregistries</code>\\</li> <li>Kind: <code>ContainerRegistry</code></li> </ul> <p>Managed OCI registries for Azure and hybrid workloads.</p> <p><code>ContainerRegistry</code> brings Azure Container Registry configuration to the same source file as Terraform and kubectl style workflows. Capture SKU, retention, encryption, and network rules once and share them broadly.</p>"},{"location":"reference/providers/az/#configuration-examples","title":"Configuration Examples","text":"YAMLHCL <pre><code>apiVersion: az/v1\nkind: ContainerRegistry\nmetadata:\n  name: platform-shared\nspec:\n  subscriptionId: 00000000-1111-2222-3333-444444444444\n  resourceGroup: rg-platform\n  location: australiaeast\n  sku: Premium\n  adminUserEnabled: false\n  retentionPolicy:\n    days: 30\n    status: enabled\n  networkRuleSet:\n    defaultAction: Deny\n    ipRules:\n      - action: Allow\n        value: 10.10.0.0/16\n</code></pre> <pre><code>resource \"azurerm_container_registry\" \"platform\" {\n  name                = \"platform-shared\"\n  resource_group_name = azurerm_resource_group.platform.name\n  location            = azurerm_resource_group.platform.location\n  sku                 = \"Premium\"\n  admin_enabled       = false\n\n  retention_policy {\n    days    = 30\n    enabled = true\n  }\n\n  network_rule_set {\n    default_action = \"Deny\"\n    ip_rule {\n      action = \"Allow\"\n      ip_range = \"10.10.0.0/16\"\n    }\n  }\n}\n</code></pre>"},{"location":"reference/providers/az/#required-arguments","title":"Required Arguments","text":"Name Type Description <code>subscriptionId</code> <code>string</code> Subscription that owns the registry. <code>resourceGroup</code> <code>string</code> Resource group where the registry is deployed. <code>location</code> <code>string</code> Azure region for the registry. <code>sku</code> <code>string</code> SKU tier such as <code>Basic</code>, <code>Standard</code>, or <code>Premium</code>."},{"location":"reference/providers/az/#optional-arguments","title":"Optional Arguments","text":"Name Type Description Default <code>adminUserEnabled</code> <code>bool</code> Controls whether the legacy admin user/password is available. \u2014 <code>retentionPolicy</code> <code>object</code> Retention policy block with <code>days</code> and <code>status</code> keys. \u2014 <code>networkRuleSet</code> <code>object</code> Optional block for IP/VNet allow lists and default action. \u2014"},{"location":"reference/providers/az/#computed-attributes","title":"Computed Attributes","text":"Name Type Description <code>loginServer</code> <code>string</code> DNS hostname clients should push to. <code>id</code> <code>string</code> ARM resource ID for the registry."},{"location":"reference/providers/az/#functionapp","title":"FunctionApp","text":"<ul> <li>API Group: <code>az/v1</code>\\</li> <li>Resource Name: <code>functionapps</code>\\</li> <li>Kind: <code>FunctionApp</code></li> </ul> <p>Serverless Functions-as-a-Service on Azure.</p> <p>Azure <code>FunctionApp</code> documents consolidate the knobs for deployment slots, plan SKUs, identity, and app settings. They make it straightforward to represent both YAML and HCL views for teams that co-manage workloads.</p>"},{"location":"reference/providers/az/#configuration-examples_1","title":"Configuration Examples","text":"YAMLHCL <pre><code>apiVersion: az/v1\nkind: FunctionApp\nmetadata:\n  name: image-hooks\nspec:\n  subscriptionId: 00000000-1111-2222-3333-444444444444\n  resourceGroup: rg-serverless\n  location: australiaeast\n  planSku: EP1\n  storageAccountName: funcstate\n  runtimeStack: dotnet-isolated\n  identity:\n    type: SystemAssigned\n  appSettings:\n    FUNCTIONS_WORKER_PROCESS_COUNT: \"4\"\n    EVENT_TOPIC: image-updates\n</code></pre> <pre><code>resource \"azurerm_linux_function_app\" \"image_hooks\" {\n  name                = \"image-hooks\"\n  resource_group_name = azurerm_resource_group.serverless.name\n  location            = azurerm_resource_group.serverless.location\n  service_plan_id     = azurerm_service_plan.functions.id\n  storage_account_name       = azurerm_storage_account.funcstate.name\n  storage_account_access_key = azurerm_storage_account.funcstate.primary_access_key\n\n  app_settings = {\n    FUNCTIONS_WORKER_PROCESS_COUNT = 4\n    EVENT_TOPIC                   = \"image-updates\"\n  }\n\n  identity {\n    type = \"SystemAssigned\"\n  }\n}\n</code></pre>"},{"location":"reference/providers/az/#required-arguments_1","title":"Required Arguments","text":"Name Type Description <code>subscriptionId</code> <code>string</code> Subscription that contains the Function App. <code>resourceGroup</code> <code>string</code> Resource group where the Function App lives. <code>location</code> <code>string</code> Azure region for the app and hosting plan."},{"location":"reference/providers/az/#optional-arguments_1","title":"Optional Arguments","text":"Name Type Description Default <code>planSku</code> <code>string</code> Consumption (<code>Y1</code>), Elastic Premium (<code>EP1</code>), or Dedicated SKU. \u2014 <code>storageAccountName</code> <code>string</code> Backing storage account used for package deployment. \u2014 <code>runtimeStack</code> <code>string</code> Worker runtime, e.g. <code>dotnet-isolated</code> or <code>node</code>. \u2014 <code>identity</code> <code>object</code> Managed identity configuration for the app. \u2014 <code>appSettings</code> <code>map(string)</code> Environment variables available during execution. \u2014"},{"location":"reference/providers/az/#computed-attributes_1","title":"Computed Attributes","text":"Name Type Description <code>defaultHostname</code> <code>string</code> Public hostname automatically assigned by Azure. <code>outboundIpAddresses</code> <code>list(string)</code> Comma-separated list of possible outbound IPs."},{"location":"reference/providers/az/#virtualmachine","title":"VirtualMachine","text":"<ul> <li>API Group: <code>az/v1</code>\\</li> <li>Resource Name: <code>virtualmachines</code>\\</li> <li>Kind: <code>VirtualMachine</code></li> </ul> <p>General purpose compute on Azure Virtual Machines.</p> <p>Use <code>VirtualMachine</code> to describe provisioned Azure compute instances, whether you manage them with Terraform, ARM, or the Portal. The schema focuses on the knobs infrastructure teams change most frequently: the source image, SKU, networking attachments, and OS customization.</p>"},{"location":"reference/providers/az/#configuration-examples_2","title":"Configuration Examples","text":"YAMLHCL <pre><code>apiVersion: az/v1\nkind: VirtualMachine\nmetadata:\n  name: vm-web-01\nspec:\n  subscriptionId: 00000000-1111-2222-3333-444444444444\n  resourceGroup: rg-web\n  location: australiaeast\n  size: Standard_D4s_v5\n  networkInterfaceIds:\n    - /subscriptions/.../networkInterfaces/web-nic\n  osDisk:\n    caching: ReadWrite\n    storageAccountType: Premium_LRS\n  sourceImage:\n    publisher: Canonical\n    offer: 0001-com-ubuntu-server-jammy\n    sku: 22_04-lts\n    version: latest\n  adminUsername: ubuntu\n  sshPublicKeys:\n    - \"ssh-ed25519 AAAA...\"\n</code></pre> <pre><code>resource \"azurerm_linux_virtual_machine\" \"web\" {\n  name                = \"vm-web-01\"\n  resource_group_name = azurerm_resource_group.web.name\n  location            = azurerm_resource_group.web.location\n  size                = \"Standard_D4s_v5\"\n  admin_username      = \"ubuntu\"\n  network_interface_ids = [\n    azurerm_network_interface.web.id,\n  ]\n\n  source_image_reference {\n    publisher = \"Canonical\"\n    offer     = \"0001-com-ubuntu-server-jammy\"\n    sku       = \"22_04-lts\"\n    version   = \"latest\"\n  }\n\n  os_disk {\n    caching              = \"ReadWrite\"\n    storage_account_type = \"Premium_LRS\"\n  }\n}\n</code></pre>"},{"location":"reference/providers/az/#required-arguments_2","title":"Required Arguments","text":"Name Type Description <code>subscriptionId</code> <code>string</code> Azure subscription that owns the VM. <code>resourceGroup</code> <code>string</code> Target resource group for the VM and supporting objects. <code>location</code> <code>string</code> Azure region, e.g. <code>australiaeast</code>. <code>size</code> <code>string</code> VM SKU defining vCPU, RAM, and network bandwidth."},{"location":"reference/providers/az/#optional-arguments_2","title":"Optional Arguments","text":"Name Type Description Default <code>networkInterfaceIds</code> <code>list(string)</code> NIC resource IDs wired to the VM. \u2014 <code>sourceImage</code> <code>object</code> Publisher/offer/sku triple that defines the OS image. \u2014 <code>osDisk</code> <code>object</code> Disk storage settings such as caching and SKU. \u2014 <code>adminUsername</code> <code>string</code> Linux user provisioned for SSH. \u2014 <code>sshPublicKeys</code> <code>list(string)</code> Authorized keys that enable SSH login. \u2014"},{"location":"reference/providers/az/#computed-attributes_2","title":"Computed Attributes","text":"Name Type Description <code>id</code> <code>string</code> ARM resource ID of the VM. <code>privateIps</code> <code>list(string)</code> IPv4 addresses assigned to attached NICs."},{"location":"reference/providers/gcp/","title":"Google Cloud Provider Reference","text":""},{"location":"reference/providers/gcp/#google-cloud-provider-reference","title":"Google Cloud Provider Reference","text":"<p>Source of truth</p> <p>Definitions live under <code>examples/api-definitions/apis/gcp</code>. Update the API definitions and re-run <code>make docs-reference</code>.</p>"},{"location":"reference/providers/gcp/#v1","title":"v1","text":"Resource Kind Short Names Categories <code>artifactregistries</code> <code>ArtifactRegistry</code> gar \u2014 <code>cloudfunctions</code> <code>CloudFunction</code> gcf \u2014 <code>computeinstances</code> <code>ComputeInstance</code> gce \u2014"},{"location":"reference/providers/gcp/#artifactregistry","title":"ArtifactRegistry","text":"<ul> <li>API Group: <code>gcp/v1</code>\\</li> <li>Resource Name: <code>artifactregistries</code>\\</li> <li>Kind: <code>ArtifactRegistry</code></li> </ul> <p>Regional Artifact Registry repositories.</p> <p>Align Artifact Registry configuration\u2014format, replication, cleanup policies\u2014between teams by documenting them once in the API definitions. Registries can back Docker/OCI images, Maven, npm, or generic artifacts.</p>"},{"location":"reference/providers/gcp/#configuration-examples","title":"Configuration Examples","text":"YAMLHCL <pre><code>apiVersion: gcp/v1\nkind: ArtifactRegistry\nmetadata:\n  name: shared-images\nspec:\n  project: sample-project\n  location: australia-southeast1\n  format: DOCKER\n  description: Golden base images\n  dockerConfig:\n    immutableTags: true\n  cleanupPolicyDryRun: false\n  cleanupPolicies:\n    - id: keep-release\n      action: KEEP\n      condition:\n        tagState: TAGGED\n        tagPrefix: release-\n        olderThanDays: 60\n</code></pre> <pre><code>resource \"google_artifact_registry_repository\" \"shared\" {\n  repository_id = \"shared-images\"\n  project       = \"sample-project\"\n  location      = \"australia-southeast1\"\n  description   = \"Golden base images\"\n  format        = \"DOCKER\"\n\n  docker_config {\n    immutable_tags = true\n  }\n}\n</code></pre>"},{"location":"reference/providers/gcp/#required-arguments","title":"Required Arguments","text":"Name Type Description <code>project</code> <code>string</code> GCP project that owns the repository. <code>location</code> <code>string</code> Region or multi-region location for storage. <code>format</code> <code>string</code> Repository format such as <code>DOCKER</code>, <code>MAVEN</code>, or <code>NPM</code>."},{"location":"reference/providers/gcp/#optional-arguments","title":"Optional Arguments","text":"Name Type Description Default <code>description</code> <code>string</code> Optional human readable summary. \u2014 <code>dockerConfig</code> <code>object</code> Block controlling tag immutability and vulnerability scanning. \u2014 <code>cleanupPolicies</code> <code>list(object)</code> Policy list that keeps/denies packages by age or tag patterns. \u2014 <code>cleanupPolicyDryRun</code> <code>bool</code> When true, reports what would be deleted without removing anything. \u2014"},{"location":"reference/providers/gcp/#computed-attributes","title":"Computed Attributes","text":"Name Type Description <code>repositoryId</code> <code>string</code> Identifier portion of the repository URL. <code>uri</code> <code>string</code> Artifact Registry endpoint for the repository."},{"location":"reference/providers/gcp/#cloudfunction","title":"CloudFunction","text":"<ul> <li>API Group: <code>gcp/v1</code>\\</li> <li>Resource Name: <code>cloudfunctions</code>\\</li> <li>Kind: <code>CloudFunction</code></li> </ul> <p>Google Cloud Functions (2nd gen).</p> <p>The <code>CloudFunction</code> schema models both build- and deploy-time switches for Functions 2nd gen, including build images, service accounts, concurrency, and event triggers. It's ideal when you need to show YAML and HCL equivalents.</p>"},{"location":"reference/providers/gcp/#configuration-examples_1","title":"Configuration Examples","text":"YAMLHCL <pre><code>apiVersion: gcp/v1\nkind: CloudFunction\nmetadata:\n  name: gcf-image-processor\nspec:\n  project: sample-project\n  region: us-central1\n  runtime: nodejs20\n  serviceAccountEmail: gcf-runtime@sample-project.iam.gserviceaccount.com\n  buildConfig:\n    entryPoint: handler\n    environmentVariables:\n      NODE_ENV: production\n    source:\n      storageSource:\n        bucket: artifacts-sample-project\n        object: functions/image-processor.zip\n  serviceConfig:\n    availableMemoryMb: 1024\n    timeoutSeconds: 60\n    minInstanceCount: 0\n    maxInstanceCount: 10\n  eventTrigger:\n    triggerRegion: us-central1\n    eventType: google.cloud.storage.object.v1.finalized\n    eventFilters:\n      - attribute: bucket\n        value: raw-images\n</code></pre> <pre><code>resource \"google_cloudfunctions2_function\" \"image\" {\n  name        = \"gcf-image-processor\"\n  project     = \"sample-project\"\n  location    = \"us-central1\"\n  description = \"Processes new objects\"\n\n  build_config {\n    runtime     = \"nodejs20\"\n    entry_point = \"handler\"\n    source {\n      storage_source {\n        bucket = \"artifacts-sample-project\"\n        object = \"functions/image-processor.zip\"\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count = 10\n    min_instance_count = 0\n    available_memory   = \"1024M\"\n    timeout_seconds    = 60\n    service_account_email = \"gcf-runtime@sample-project.iam.gserviceaccount.com\"\n  }\n\n  event_trigger {\n    event_type  = \"google.cloud.storage.object.v1.finalized\"\n    trigger_region = \"us-central1\"\n    event_filters {\n      attribute = \"bucket\"\n      value     = \"raw-images\"\n    }\n  }\n}\n</code></pre>"},{"location":"reference/providers/gcp/#required-arguments_1","title":"Required Arguments","text":"Name Type Description <code>project</code> <code>string</code> Google Cloud project ID. <code>region</code> <code>string</code> Region where the function runs. <code>runtime</code> <code>string</code> Execution runtime such as <code>nodejs20</code> or <code>python311</code>."},{"location":"reference/providers/gcp/#optional-arguments_1","title":"Optional Arguments","text":"Name Type Description Default <code>serviceAccountEmail</code> <code>string</code> Identity used during execution. \u2014 <code>buildConfig</code> <code>object</code> Source bundle, entrypoint, and build environment variables. \u2014 <code>serviceConfig</code> <code>object</code> Scaling, timeout, and networking settings for execution. \u2014 <code>eventTrigger</code> <code>object</code> Pub/Sub, Eventarc, or Storage trigger configuration. \u2014"},{"location":"reference/providers/gcp/#computed-attributes_1","title":"Computed Attributes","text":"Name Type Description <code>state</code> <code>string</code> Deployment state reported by Cloud Functions. <code>updateTime</code> <code>string</code> Timestamp of the latest deploy."},{"location":"reference/providers/gcp/#computeinstance","title":"ComputeInstance","text":"<ul> <li>API Group: <code>gcp/v1</code>\\</li> <li>Resource Name: <code>computeinstances</code>\\</li> <li>Kind: <code>ComputeInstance</code></li> </ul> <p>Compute Engine virtual machines.</p> <p><code>ComputeInstance</code> resources expose the same knobs Terraform offers for Google Compute Engine, but through babyctl-native YAML. That includes boot disks, attached GPUs, metadata, and network interfaces.</p>"},{"location":"reference/providers/gcp/#configuration-examples_2","title":"Configuration Examples","text":"YAMLHCL <pre><code>apiVersion: gcp/v1\nkind: ComputeInstance\nmetadata:\n  name: gce-api-01\nspec:\n  project: sample-project\n  zone: us-central1-a\n  machineType: e2-standard-4\n  labels:\n    env: prod\n    service: api\n  bootDisk:\n    image: projects/debian-cloud/global/images/family/debian-12\n    sizeGb: 50\n  networkInterfaces:\n    - network: default\n      subnetwork: default\n      accessConfigs:\n        - natIP: 34.118.10.10\n  metadata:\n    startup-script: |\n      #!/bin/bash\n      apt-get update &amp;&amp; apt-get install -y nginx\n</code></pre> <pre><code>resource \"google_compute_instance\" \"api\" {\n  name         = \"gce-api-01\"\n  project      = \"sample-project\"\n  zone         = \"us-central1-a\"\n  machine_type = \"e2-standard-4\"\n\n  boot_disk {\n    initialize_params {\n      image = \"debian-cloud/debian-12\"\n      size  = 50\n    }\n  }\n\n  network_interface {\n    network    = \"default\"\n    subnetwork = \"default\"\n\n    access_config {\n      nat_ip = \"34.118.10.10\"\n    }\n  }\n\n  metadata = {\n    startup-script = file(\"scripts/startup.sh\")\n  }\n\n  labels = {\n    env     = \"prod\"\n    service = \"api\"\n  }\n}\n</code></pre>"},{"location":"reference/providers/gcp/#required-arguments_2","title":"Required Arguments","text":"Name Type Description <code>project</code> <code>string</code> Google Cloud project that owns the instance. <code>zone</code> <code>string</code> Compute Engine zone such as <code>us-central1-a</code>. <code>machineType</code> <code>string</code> Machine type defining vCPU and RAM."},{"location":"reference/providers/gcp/#optional-arguments_2","title":"Optional Arguments","text":"Name Type Description Default <code>bootDisk</code> <code>object</code> Boot disk configuration including image family and size. \u2014 <code>networkInterfaces</code> <code>list(object)</code> Primary and additional NIC definitions including access configs. \u2014 <code>labels</code> <code>map(string)</code> Optional key/value labels for the instance. \u2014 <code>metadata</code> <code>map(string)</code> Custom metadata entries; <code>startup-script</code> is supported. \u2014"},{"location":"reference/providers/gcp/#computed-attributes_2","title":"Computed Attributes","text":"Name Type Description <code>selfLink</code> <code>string</code> Full resource URL for the instance. <code>networkIPs</code> <code>list(string)</code> Internal IP addresses assigned to NICs."}]}